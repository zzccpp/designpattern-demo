

>>>设计模式从来都是组合使用的,你中有我.我中有你

>>>>>参考   https://www.runoob.com/design-pattern


策略模式&模板模式

策略模式:只有选择权(由用户自己选择已有的固定算法)
模板模式:侧重的点不是选择,你没得选择,你必须这么做你可以参与某一部分内容自定义


委派模式(属于行为模型,不在23中设计模式中)-静态代理与策略模式的组合
静态代理的一种(全权代理)
委派模式比较代理模式
--委派注重的是结果    --代理模式注重的是过程
委派模式比较策略模式
--委派注重内部灵活和复用    --策略注重扩展


=====装饰模式(包装器模式)========
应用场景：在我们的项目中遇到这样一个问题：我们的项目需要连接多个数据库，而且不同的客户在每
次访问中根据需要会去访问不同的数据库。我们以往在 Spring 和 Hibernate 框架中总是配置一个数据
源，因而 SessionFactory 的 DataSource 属性总是指向这个数据源并且恒定不变，所有 DAO 在使用
SessionFactory 的时候都是通过这个数据源访问数据库。但是现在，由于项目的需要，我们的 DAO 在
访问 SessionFactory 的时候都不得不在多个数据源中不断切换，问题就出现了：如何让
SessionFactory 在执行数据持久化的时候，根据客户的需求能够动态切换不同的数据源？我们能不能
在 Spring 的框架下通过少量修改得到解决？是否有什么设计模式可以利用呢？
首先想到在 Spring 的 ApplicationContext 中配置所有的 DataSource。这些 DataSource 可能是各
种不同类型的，比如不同的数据库：Oracle、SQL Server、MySQL 等，也可能是不同的数据源：比如
Apache 提 供 的 org.apache.commons.dbcp.BasicDataSource 、 Spring 提 供 的
org.springframework.jndi.JndiObjectFactoryBean 等。然后 SessionFactory 根据客户的每次
请求，将 DataSource 属性设置成不同的数据源，以到达切换数据源的目的。
Spring 中用到的包装器模式在类名上有两种表现：一种是类名中含有 Wrapper，另一种是类名中含有
Decorator。基本上都是动态地给一个对象添加一些额外的职责。



AOP:面向切面编程
OOP:封装、继承、多态（一切皆对象）
BOP:Bean与Bean之间的关系,不希望每次认为重复管理,由程序自动管理,Spring开始就是自从Bean的管理开始
IOC:控制反转   创建对象的控制权反转  new，谁使用谁new,有了Spring以后,所有的Bean都有Spring来new,
所以才叫控制反转 new出来以后的对象需要统一管理起来，所以才有了IOC容器(MAP)
DI技术:解决对象动态赋值的问题，动态调用getter、setter（采用反射）

Spring加载步骤:定位、摘录、注册:再确定需不要初始化Spring















>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
各设计模式对比及编程思想总结
设计模式 一句话归纳
工厂模式（Factory） 只对结果负责，不要三无产品。
单例模式（Singleton） 保证独一无二。
适配器模式（Adapter） 需要一个转换头（兼容）。
装饰器模式（Decorator） 需要包装，但不改变本质(同宗同源)。
代理模式（Proxy） 办事要求人，所以找代理。
观察者模式（Observer） 完成时通知我。
策略模式（Strategy） 我行我素，达到目的就行。
模板模式（Template） 流程标准化，原料自己加。
委派模式（Delegate） 干活是你的（普通员工），功劳是我的（项目经理）。
原型模式（Prototype） 拔一根猴毛，吹出千万个。